{"version":3,"sources":["shaders/vertex.glsl","shaders/fragment.glsl","controls.ts","index.ts"],"names":["module","exports"],"mappings":";AAAAA,OAAOC,QAAQ;;ACAfD,OAAOC,QAAQ;;ACEF,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,kBAAA,EAAA,QAAA,aAAe,SAAC,GACnB,IAED,GAAL,SAAK,GACD,EAAA,QAAA,IACA,EAAA,SAAA,IACA,EAAA,KAAA,IACA,EAAA,MAAA,IAJJ,CAAK,IAAA,EAAI,KAOH,IAAA,EAAkC,GAGpC,OAAO,OAAO,GAAM,QAAQ,SAAC,GAAO,OAAA,EAAS,IAAK,IAIhD,IAAA,EAAiB,SAAC,GAChB,OAAO,OAAO,GAAM,SAAS,EAAE,OAC/B,EAAS,EAAE,MAAe,IAGlC,SAAS,iBAAiB,UAAW,GAOrC,SAAS,iBAAiB,QALL,SAAC,GACd,OAAO,OAAO,GAAM,SAAS,EAAE,OAC/B,EAAS,EAAE,MAAe,KAK5B,IAAA,EAAW,YAAY,WACrB,EAAS,EAAK,WACd,EAAM,SAAW,EAAM,eAEvB,EAAS,EAAK,YACd,EAAM,SAAW,EAAM,eAEvB,EAAS,EAAK,QACd,EAAM,SAAW,EAAM,eAEvB,EAAS,EAAK,SACd,EAAM,SAAW,EAAM,gBAzCT,IA6Cf,OAAA,WACH,SAAS,oBAAoB,UAAW,GACxC,SAAS,oBAAoB,QAAS,GACtC,cAAc;;ACsJtB,aAAA,IAAA,EAAA,MAAA,KAAA,iBAAA,SAAA,GAAA,OAAA,GAAA,EAAA,WAAA,EAAA,CAAA,QAAA,IAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAzMA,IAwGI,EAxGJ,EAAA,EAAA,QAAA,0BACA,EAAA,EAAA,QAAA,4BACA,EAAA,QAAA,cAEM,EAAQ,CACV,QAAS,EACT,QAAS,EACT,QAAS,EACT,UAAW,EACX,YAAa,EACb,cAAe,IAEf,UAAW,GAQT,EAAS,SAAC,GAAc,OAAA,SAAC,GAEtB,IADD,IAAA,EAAgB,GACX,EAAI,EAAG,EAAI,EAAG,IACnB,EAAS,EAAO,OAAO,GAEpB,OAAA,IAGL,EAAQ,SAAC,GACX,OAAA,MAAM,GACD,KAAK,MACL,IAAI,SAAC,EAAG,GAAM,OAAA,KAEjB,EAAkB,WACd,IAAA,EAAS,SAAS,cAAc,UACtC,EAAO,OAAS,OAAO,YAEvB,EAAO,MAAQ,EAAO,OACtB,SAAS,KAAK,YAAY,GAEpB,IAAA,EAAK,EAAO,WAAW,UACzB,IAAC,EACK,MAAA,IAAI,MAAM,iDAEb,OAAA,GAQL,EAAa,SAAC,GACV,IAAA,EAAgB,GA0Bf,OAzBP,EAAI,MAAM,MAAM,QAAQ,SAAC,EAAM,GAC3B,OAAA,EAAK,MAAM,IAAI,QAAQ,SAAC,EAAM,GAClB,OAAA,GACC,IAAA,IACD,EAAM,KAAK,CACP,SAAU,CAAM,GAAJ,EAAW,EAAJ,EAAO,GAC1B,MAAO,CAAC,EAAG,EAAG,KAElB,MACC,IAAA,IACD,EAAM,KAAK,CACP,SAAU,CAAM,GAAJ,EAAW,EAAJ,EAAO,GAC1B,MAAO,CAAC,EAAG,EAAG,KAElB,MACC,IAAA,IACD,EAAM,KAAK,CACP,SAAU,CAAM,GAAJ,EAAW,EAAJ,EAAO,GAC1B,MAAO,CAAC,EAAG,EAAG,UAO3B,GAiBL,EAAQ,EAAW,mDAMzB,QAAQ,IAAI,GAIZ,IAAM,EAAQ,SAAC,GAA0B,IAAA,EAAA,EAErC,EAAG,WAAW,IAAM,IAAM,IAAM,GAG1B,IAAA,EAAe,EAAG,aAAa,EAAG,eACxC,EAAG,aAAa,EAAc,EAAA,SAC9B,EAAG,cAAc,GACZ,EAAG,mBAAmB,EAAc,EAAG,iBACxC,QAAQ,MAAM,EAAG,iBAAiB,IAGhC,IAAA,EAAiB,EAAG,aAAa,EAAG,iBAC1C,EAAG,aAAa,EAAgB,EAAA,SAChC,EAAG,cAAc,GACZ,EAAG,mBAAmB,EAAgB,EAAG,iBAC1C,QAAQ,MAAM,EAAG,iBAAiB,IAItC,EAAU,EAAG,gBACb,EAAG,aAAa,EAAS,GACzB,EAAG,aAAa,EAAS,GACzB,EAAG,YAAY,GACV,EAAG,oBAAoB,EAAS,EAAG,cACpC,QAAQ,MAAM,EAAG,kBAAkB,IAIvC,EAAG,WAAW,GAMR,IAAA,EAAY,IAAI,cAClB,EAAC,IAAgB,OAAM,MAAA,EAChB,EAAM,IAAI,SAAC,GAAS,OAAA,EAAO,GAAP,CAAW,EAAK,cAGzC,EAAiB,EAAG,eAC1B,EAAG,WAAW,EAAG,aAAc,GAC/B,EAAG,WAAW,EAAG,aAAc,EAAW,EAAG,aAC7C,EAAG,oBAAoB,EAAG,EAAG,EAAG,OAAO,EAAO,EAAG,GACjD,EAAG,wBAAwB,GAIrB,IAAA,EAAU,IAAI,aAAa,EAAO,EAAM,OAAb,CAAqB,EAAM,MACtD,EAAc,EAAG,eACvB,EAAG,WAAW,EAAG,aAAc,GAC/B,EAAG,WAAW,EAAG,aAAc,EAAS,EAAG,aAC3C,EAAG,oBAAoB,EAAG,EAAG,EAAG,OAAO,EAAO,EAAG,GACjD,EAAG,wBAAwB,GAIrB,IAAA,GAAY,EAAC,IAAgB,OAAM,MAAA,EAClC,EAAM,IAAI,SAAC,GAAS,OAAA,EAAO,GAAP,CAAW,EAAK,UAE3C,QAAQ,IAAI,GACN,IAAA,EAAS,IAAI,aAAa,GAC1B,EAAc,EAAG,eACvB,EAAG,WAAW,EAAG,aAAc,GAC/B,EAAG,WAAW,EAAG,aAAc,EAAQ,EAAG,aAC1C,EAAG,oBAAoB,EAAG,EAAG,EAAG,OAAO,EAAO,EAAG,GACjD,EAAG,wBAAwB,GAE3B,EAAG,OAAO,EAAG,YACb,EAAG,UAAU,EAAG,OAGd,EAAO,SAAC,GACV,EAAM,WAAa,IAEb,IAAA,EAAU,EAAG,mBAAmB,EAAS,mBAC/C,EAAG,WAAW,EAAS,CAAC,EAAM,QAAS,EAAM,QAAS,EAAM,UAEtD,IAAA,EAAY,EAAG,mBAAmB,EAAS,cACjD,EAAG,UAAU,EAAW,EAAM,WAG9B,EAAG,MAAM,EAAG,kBAGZ,EAAG,WAAW,EAAG,UAAW,EAAkB,GAAf,EAAM,SAGnC,EAAO,WACH,IAAA,EAAK,IACX,EAAM,GACN,YAAY,WAAM,OAAA,EAAK,IAAK,IAC5B,EAAA,aAAa,IAGjB,OAAO,iBAAiB,mBAAoB","file":"src.ff1a918e.js","sourceRoot":"../src","sourcesContent":["module.exports=\"#version 300 es\\n#define GLSLIFY 1\\n\\nlayout (location=0) in vec3 position;\\nlayout (location=1) in float index;\\nlayout (location=2) in vec3 color;\\n\\nout vec3 vColor;\\n\\nuniform vec3 camera_position;\\nuniform float some_angle;\\n\\nvec3 vertex_offsets[36] = vec3[36](\\n    //front\\n    vec3(-1.,  1.,  1.),\\n    vec3(-1., -1.,  1.),\\n    vec3( 1.,  1.,  1.),\\n\\n    vec3(-1., -1.,  1.),\\n    vec3( 1., -1.,  1.),\\n    vec3( 1.,  1.,  1.),\\n\\n    //back\\n    vec3(-1.,  1.,  -1.),\\n    vec3(-1., -1.,  -1.),\\n    vec3( 1.,  1.,  -1.),\\n\\n    vec3(-1., -1.,  -1.),\\n    vec3( 1., -1.,  -1.),\\n    vec3( 1.,  1.,  -1.),\\n\\n    //top\\n    vec3(-1.,  1.,  1.),\\n    vec3(-1.,  1., -1.),\\n    vec3( 1.,  1.,  1.),\\n\\n    vec3( 1.,  1., -1.),\\n    vec3(-1.,  1., -1.),\\n    vec3( 1.,  1.,  1.),\\n\\n    //bottom\\n    vec3(-1., -1.,  1.),\\n    vec3(-1., -1., -1.),\\n    vec3( 1., -1.,  1.),\\n\\n    vec3( 1., -1., -1.),\\n    vec3(-1., -1., -1.),\\n    vec3( 1., -1.,  1.),\\n\\n    //left\\n    vec3(-1., -1.,  1.),\\n    vec3(-1.,  1.,  1.),\\n    vec3(-1.,  1., -1.),\\n\\n    vec3(-1., -1.,  1.),\\n    vec3(-1., -1., -1.),\\n    vec3(-1.,  1., -1.),\\n\\n    //right\\n    vec3( 1., -1.,  1.),\\n    vec3( 1.,  1.,  1.),\\n    vec3( 1.,  1., -1.),\\n\\n    vec3( 1., -1.,  1.),\\n    vec3( 1., -1., -1.),\\n    vec3( 1.,  1., -1.)\\n);\\n\\nfloat[6] colorScale = float[6](\\n    1.0, //front\\n    0.3, //back\\n    0.4, //top\\n    0.7, //bottom\\n    0.6, //left\\n    0.8  //right\\n);\\n\\nfloat[6] depth = float[6](\\n     1.0, //front\\n     1.0, //back\\n     1.0, //top\\n     1.0, //bottom\\n     1.0, //left\\n     1.0  //right\\n);\\n\\nvoid main() {\\n    vec4 local_position = vec4(vertex_offsets[uint(index)], 1.);\\n\\n    mat4 positioner = mat4(\\n        1.,             0.,             0.,             0.,\\n        0.,             1.,             0.,             0.,\\n        0.,             0.,             1.,             0.,\\n        position[0],    position[1],    position[2],    1.\\n    );\\n\\n    vec4 world_position = positioner * local_position;\\n\\n    mat4 camera_translation_matrix = mat4(\\n        1.,                 0.,                 0.,                 0.,\\n        0.,                 1.,                 0.,                 0.,\\n        .5,                 .5,                 -1.,                0.,\\n        camera_position[0], camera_position[1], camera_position[2], camera_position[2]\\n    );\\n\\n    mat4 camera_rotation_matrix = mat4(\\n        cos(some_angle),    -sin(some_angle),   0.,     0.,\\n        sin(some_angle),    cos(some_angle),    0.,     0.,\\n        0,                  0,                  1.,     0.,\\n        0.,                 0.,                 0.,     1.\\n    );\\n\\n    gl_Position = camera_rotation_matrix * camera_translation_matrix * world_position;\\n\\n//    gl_Position = vec4(\\n//        camera_position + vec3(\\n//            position[0] + .5 * position[2],  // x\\n//            position[1] + .5 * position[2],  // y\\n//            -position[2]                    // z\\n//        ),\\n//        2. + camera_position[2]                               // w\\n//    );\\n    vColor = colorScale[uint(index/6.)] * vec3(color[0], color[1], color[2]);\\n}\\n\\n/*\\n   y\\n   |\\n   |    z\\n   |   /\\n   |  /\\n   | /\\n   |/_______x\\n\\n*/\\n\";","module.exports=\"#version 300 es\\nprecision highp float;\\n#define GLSLIFY 1\\n\\nin vec3 vColor;\\nout vec4 fragColor;\\n\\nvoid main() {\\n    fragColor = vec4(vColor, 1.0);\\n}\\n\";","import { State } from \"./index\";\n\nexport const initControls = (state: State) => {\n    const intervalSpeed = 10;\n\n    enum KEYS {\n        FORWARD = \"w\",\n        BACKWARD = \"s\",\n        LEFT = \"a\",\n        RIGHT = \"d\",\n    }\n\n    const keyState: Record<KEYS, boolean> = {} as any;\n\n    const clearKeyState = () =>\n        Object.values(KEYS).forEach((k) => (keyState[k] = false));\n\n    clearKeyState();\n\n    const keyDownHandler = (e: KeyboardEvent) => {\n        if (Object.values(KEYS).includes(e.key as KEYS)) {\n            keyState[e.key as KEYS] = true;\n        }\n    };\n    document.addEventListener(\"keydown\", keyDownHandler);\n\n    const keyupHandler = (e: KeyboardEvent) => {\n        if (Object.values(KEYS).includes(e.key as KEYS)) {\n            keyState[e.key as KEYS] = false;\n        }\n    };\n    document.addEventListener(\"keyup\", keyupHandler);\n\n    const interval = setInterval(() => {\n        if (keyState[KEYS.FORWARD]) {\n            state.cameraZ += state.movementSpeed;\n        }\n        if (keyState[KEYS.BACKWARD]) {\n            state.cameraZ -= state.movementSpeed;\n        }\n        if (keyState[KEYS.LEFT]) {\n            state.cameraX -= state.movementSpeed;\n        }\n        if (keyState[KEYS.RIGHT]) {\n            state.cameraX += state.movementSpeed;\n        }\n    }, intervalSpeed);\n\n    return () => {\n        document.removeEventListener(\"keydown\", keyDownHandler);\n        document.removeEventListener(\"keyup\", keyDownHandler);\n        clearInterval(interval);\n    };\n};\n","import vertexShaderSource from \"./shaders/vertex.glsl\";\nimport fragmentShaderSource from \"./shaders/fragment.glsl\";\nimport { initControls } from \"./controls\";\n\nconst state = {\n    cameraX: 0,\n    cameraY: 0,\n    cameraZ: 5,\n    cameraPhi: 0, // angle with z axis around y axis (0: in z-direction, pi: -z direction)\n    cameraTheta: 0, // angle with x,y plane\n    movementSpeed: 0.04,\n\n    someAngle: 0,\n};\nexport type State = typeof state;\n//\n// setInterval(() => {\n//     console.log(state);\n// }, 1000);\n\nconst repeat = (n: number) => (x: any[]) => {\n    let result: any[] = [];\n    for (let i = 0; i < n; i++) {\n        result = result.concat(x);\n    }\n    return result;\n};\n\nconst range = (n: number) =>\n    Array(n)\n        .fill(null)\n        .map((_, i) => i);\n\nconst createGLContext = () => {\n    const canvas = document.createElement(\"canvas\");\n    canvas.height = window.innerHeight;\n    // canvas.width = window.innerWidth;\n    canvas.width = canvas.height;\n    document.body.appendChild(canvas);\n\n    const gl = canvas.getContext(\"webgl2\");\n    if (!gl) {\n        throw new Error(\"WebGL 2.0 is not available in your browser :(\");\n    }\n    return gl;\n};\n\ntype Cube = {\n    position: [number, number, number];\n    color: [number, number, number];\n};\n\nconst strToCubes = (str: string) => {\n    const cubes: Cube[] = [];\n    str.split(\"\\n\").forEach((line, y) =>\n        line.split(\"\").forEach((char, x) => {\n            switch (char) {\n                case \"R\":\n                    cubes.push({\n                        position: [-x * 2, y * 2, 0],\n                        color: [1, 0, 0],\n                    });\n                    break;\n                case \"G\":\n                    cubes.push({\n                        position: [-x * 2, y * 2, 0],\n                        color: [0, 1, 0],\n                    });\n                    break;\n                case \"B\":\n                    cubes.push({\n                        position: [-x * 2, y * 2, 0],\n                        color: [0, 0, 1],\n                    });\n                    break;\n            }\n        })\n    );\n\n    return cubes;\n};\n// const cubes: Array<Cube> = [\n//     {\n//         position: [0, 0, 0],\n//         color: [1, 0, 0],\n//     },\n//     {\n//         position: [2, 0, 0],\n//         color: [0, 0, 1],\n//     },\n//     {\n//         position: [4, 0, 0],\n//         color: [0, 1, 0],\n//     },\n// ];\n\nconst cubes = strToCubes(`\nRRR GGG BBBBB\n R  G G B B B\n R  GGG B B B\n`);\n\nconsole.log(cubes);\n\nlet program: WebGLProgram;\n\nconst setup = (gl: WebGL2RenderingContext) => {\n    // Set background to solid grey\n    gl.clearColor(0.25, 0.25, 0.25, 1);\n\n    // Compile shaders\n    const vertexShader = gl.createShader(gl.VERTEX_SHADER)!;\n    gl.shaderSource(vertexShader, vertexShaderSource);\n    gl.compileShader(vertexShader);\n    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {\n        console.error(gl.getShaderInfoLog(vertexShader));\n    }\n\n    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER)!;\n    gl.shaderSource(fragmentShader, fragmentShaderSource);\n    gl.compileShader(fragmentShader);\n    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {\n        console.error(gl.getShaderInfoLog(fragmentShader));\n    }\n\n    // Link shaders to WebGL program\n    program = gl.createProgram()!;\n    gl.attachShader(program, vertexShader);\n    gl.attachShader(program, fragmentShader);\n    gl.linkProgram(program);\n    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n        console.error(gl.getProgramInfoLog(program));\n    }\n\n    // Finally, activate WebGL program\n    gl.useProgram(program);\n\n    // Setup Geometry\n    // Create a Vertex Buffer Object (VBO) and bind two buffers to it\n    // 1. positions\n\n    const positions = new Float32Array(\n        ([] as number[]).concat(\n            ...cubes.map((cube) => repeat(36)(cube.position))\n        )\n    );\n    const positionBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);\n    gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);\n    gl.enableVertexAttribArray(0);\n\n    // 3. indices\n    // prettier-ignore\n    const indices = new Float32Array(repeat(cubes.length)(range(36)));\n    const indexBuffer = gl.createBuffer()!;\n    gl.bindBuffer(gl.ARRAY_BUFFER, indexBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, indices, gl.STATIC_DRAW);\n    gl.vertexAttribPointer(1, 1, gl.FLOAT, false, 0, 0);\n    gl.enableVertexAttribArray(1);\n\n    // 2. colours\n    // prettier-ignore\n    const colorData = ([] as number[]).concat(\n        ...cubes.map((cube) => repeat(36)(cube.color))\n    )\n    console.log(colorData);\n    const colors = new Float32Array(colorData);\n    const colorBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);\n    gl.vertexAttribPointer(2, 3, gl.FLOAT, false, 0, 0);\n    gl.enableVertexAttribArray(2);\n\n    gl.enable(gl.DEPTH_TEST);\n    gl.depthFunc(gl.LESS);\n};\n\nconst draw = (gl: WebGL2RenderingContext) => {\n    state.someAngle += 0.01;\n\n    const cam_loc = gl.getUniformLocation(program, \"camera_position\");\n    gl.uniform3fv(cam_loc, [state.cameraX, state.cameraY, state.cameraZ]);\n\n    const angle_loc = gl.getUniformLocation(program, \"some_angle\");\n    gl.uniform1f(angle_loc, state.someAngle);\n\n    // Fill background with one colour\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    // Instruct WebGL to draw triangles with a set of 3 vertices\n    gl.drawArrays(gl.TRIANGLES, 0, cubes.length * 36);\n};\n\nconst init = () => {\n    const gl = createGLContext();\n    setup(gl);\n    setInterval(() => draw(gl), 33);\n    initControls(state);\n};\n\nwindow.addEventListener(\"DOMContentLoaded\", init);\n"]}